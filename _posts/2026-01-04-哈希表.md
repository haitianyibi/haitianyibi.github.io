---
layout: post
title: "哈希表原理与实现"
date: 2026-01-04 10:00:00
tags: [数据结构, 哈希表]
---

# 哈希表原理与实现

## 一、哈希表概述

哈希表（Hash Table）是一种基于键值对的数据结构，通过哈希函数将键映射到数组索引，实现近乎 O(1) 的查找、插入和删除操作。

<!--more-->

### 核心概念

1. **哈希函数**：将键转换为数组索引
2. **哈希冲突**：不同的键映射到相同的索引
3. **负载因子**：元素数量 / 数组容量

---

## 二、哈希函数设计

好的哈希函数应具备：

- **均匀分布**：减少冲突
- **计算高效**：O(1) 时间复杂度
- **确定性**：相同输入产生相同输出

### 常用哈希函数

```python
# 整数哈希
def hash_int(key, size):
    return key % size

# 字符串哈希（多项式哈希）
def hash_string(key, size):
    hash_value = 0
    base = 31
    for char in key:
        hash_value = (hash_value * base + ord(char)) % size
    return hash_value

# Python 内置 hash()
hash("hello")  # 返回整数哈希值
```

```java
// Java String hashCode
public int hashCode() {
    int h = 0;
    for (int i = 0; i < value.length; i++) {
        h = 31 * h + value[i];
    }
    return h;
}
```

---

## 三、冲突解决方法

### 1. 链地址法（Separate Chaining）

每个数组位置存储一个链表，冲突的元素加入链表。

```python
class HashTableChaining:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        index = self._hash(key)
        # 检查是否已存在
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        self.table[index].append((key, value))
    
    def get(self, key):
        index = self._hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None
    
    def remove(self, key):
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return True
        return False

# 使用示例
ht = HashTableChaining()
ht.put("name", "Alice")
ht.put("age", 25)
print(ht.get("name"))  # Alice
ht.remove("name")
print(ht.get("name"))  # None
```

### 2. 开放地址法（Open Addressing）

冲突时寻找下一个可用位置。

#### 线性探测

```python
class HashTableLinearProbing:
    def __init__(self, size=10):
        self.size = size
        self.keys = [None] * size
        self.values = [None] * size
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        index = self._hash(key)
        while self.keys[index] is not None:
            if self.keys[index] == key:
                self.values[index] = value
                return
            index = (index + 1) % self.size
        self.keys[index] = key
        self.values[index] = value
    
    def get(self, key):
        index = self._hash(key)
        while self.keys[index] is not None:
            if self.keys[index] == key:
                return self.values[index]
            index = (index + 1) % self.size
        return None
```

#### 二次探测

```python
def _probe(self, key, attempt):
    base = self._hash(key)
    return (base + attempt ** 2) % self.size
```

#### 双重哈希

```python
def _double_hash(self, key, attempt):
    h1 = hash(key) % self.size
    h2 = 1 + (hash(key) % (self.size - 1))
    return (h1 + attempt * h2) % self.size
```

---

## 四、动态扩容

当负载因子超过阈值时，需要扩容。

```python
class DynamicHashTable:
    def __init__(self, initial_size=8):
        self.size = initial_size
        self.count = 0
        self.load_factor_threshold = 0.75
        self.table = [[] for _ in range(self.size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def _resize(self):
        old_table = self.table
        self.size *= 2
        self.table = [[] for _ in range(self.size)]
        self.count = 0
        
        # 重新哈希所有元素
        for bucket in old_table:
            for key, value in bucket:
                self.put(key, value)
    
    def put(self, key, value):
        # 检查是否需要扩容
        if self.count / self.size >= self.load_factor_threshold:
            self._resize()
        
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        self.table[index].append((key, value))
        self.count += 1
```

---

## 五、哈希表应用

### 1. 两数之和

```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

# 示例: nums = [2, 7, 11, 15], target = 9
# 输出: [0, 1]
```

### 2. 字符频率统计

```python
from collections import Counter

def char_frequency(s):
    return Counter(s)

# 或手动实现
def char_frequency_manual(s):
    freq = {}
    for char in s:
        freq[char] = freq.get(char, 0) + 1
    return freq
```

### 3. LRU 缓存

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()
    
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

---

## 六、时间复杂度

| 操作 | 平均 | 最坏 |
|------|------|------|
| 查找 | O(1) | O(n) |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

最坏情况发生在所有键都哈希到同一位置时。

### Java HashMap vs Hashtable

| 特性 | HashMap | Hashtable |
|------|---------|-----------|
| 线程安全 | 否 | 是 |
| null 键值 | 允许 | 不允许 |
| 性能 | 更快 | 较慢 |
| 迭代器 | fail-fast | fail-safe |
