---
layout: post
title: "二叉树完全指南"
date: 2026-01-05 10:00:00
tags: [数据结构, 二叉树, 树]
---

# 二叉树完全指南

## 一、二叉树基础

二叉树是每个节点最多有两个子节点的树形数据结构，分为左子节点和右子节点。

<!--more-->

### 基本术语

- **根节点**：树的顶部节点
- **叶节点**：没有子节点的节点
- **深度**：从根到该节点的边数
- **高度**：从该节点到最远叶节点的边数
- **层**：深度相同的节点集合

### 节点定义

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int val) {
        this.val = val;
    }
}
```

---

## 二、二叉树类型

### 1. 满二叉树（Full Binary Tree）

每个节点要么有 0 个子节点，要么有 2 个子节点。

### 2. 完全二叉树（Complete Binary Tree）

除最后一层外，其他层都是满的，最后一层节点从左到右填充。

### 3. 完美二叉树（Perfect Binary Tree）

所有内部节点都有两个子节点，所有叶节点在同一层。

### 4. 平衡二叉树（Balanced Binary Tree）

任意节点的左右子树高度差不超过 1。

```python
def is_balanced(root):
    def height(node):
        if not node:
            return 0
        left_h = height(node.left)
        right_h = height(node.right)
        if left_h == -1 or right_h == -1:
            return -1
        if abs(left_h - right_h) > 1:
            return -1
        return max(left_h, right_h) + 1
    
    return height(root) != -1
```

---

## 三、二叉树遍历

### 1. 深度优先遍历（DFS）

#### 前序遍历（根 → 左 → 右）

```python
# 递归
def preorder_recursive(root):
    if not root:
        return []
    return [root.val] + preorder_recursive(root.left) + preorder_recursive(root.right)

# 迭代
def preorder_iterative(root):
    if not root:
        return []
    result = []
    stack = [root]
    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    return result
```

#### 中序遍历（左 → 根 → 右）

```python
# 递归
def inorder_recursive(root):
    if not root:
        return []
    return inorder_recursive(root.left) + [root.val] + inorder_recursive(root.right)

# 迭代
def inorder_iterative(root):
    result = []
    stack = []
    current = root
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right
    return result
```

#### 后序遍历（左 → 右 → 根）

```python
# 递归
def postorder_recursive(root):
    if not root:
        return []
    return postorder_recursive(root.left) + postorder_recursive(root.right) + [root.val]

# 迭代
def postorder_iterative(root):
    if not root:
        return []
    result = []
    stack = [root]
    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    return result[::-1]  # 反转结果
```

### 2. 广度优先遍历（BFS）/ 层序遍历

```python
from collections import deque

def level_order(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level_size = len(queue)
        level = []
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

---

## 四、二叉搜索树（BST）

二叉搜索树满足：左子树所有节点值 < 根节点值 < 右子树所有节点值。

### 查找操作

```python
def search_bst(root, val):
    if not root or root.val == val:
        return root
    if val < root.val:
        return search_bst(root.left, val)
    return search_bst(root.right, val)
```

### 插入操作

```python
def insert_bst(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = insert_bst(root.left, val)
    else:
        root.right = insert_bst(root.right, val)
    return root
```

### 删除操作

```python
def delete_bst(root, key):
    if not root:
        return None
    
    if key < root.val:
        root.left = delete_bst(root.left, key)
    elif key > root.val:
        root.right = delete_bst(root.right, key)
    else:
        # 找到要删除的节点
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        
        # 找到右子树最小值替换
        min_node = root.right
        while min_node.left:
            min_node = min_node.left
        root.val = min_node.val
        root.right = delete_bst(root.right, min_node.val)
    
    return root
```

### 验证 BST

```python
def is_valid_bst(root):
    def validate(node, low=float('-inf'), high=float('inf')):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return validate(node.left, low, node.val) and \
               validate(node.right, node.val, high)
    
    return validate(root)
```

---

## 五、常见问题

### 1. 最大深度

```python
def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

### 2. 最近公共祖先（LCA）

```python
def lowest_common_ancestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    if left and right:
        return root
    return left if left else right
```

### 3. 路径总和

```python
def has_path_sum(root, target_sum):
    if not root:
        return False
    if not root.left and not root.right:
        return root.val == target_sum
    return has_path_sum(root.left, target_sum - root.val) or \
           has_path_sum(root.right, target_sum - root.val)
```

### 4. 翻转二叉树

```python
def invert_tree(root):
    if not root:
        return None
    root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root
```

---

## 六、时间复杂度

| 操作 | 平均 | 最坏（退化为链表）|
|------|------|------------------|
| 查找 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |
| 遍历 | O(n) | O(n) |
