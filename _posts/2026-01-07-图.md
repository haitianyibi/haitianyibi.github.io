---
layout: post
title: "图论基础与算法"
date: 2026-01-07 10:00:00
tags: [数据结构, 图, 算法]
---

# 图论基础与算法

## 一、图的基本概念

图（Graph）由顶点（Vertex）和边（Edge）组成，用于表示多对多的关系。

<!--more-->

### 基本术语

- **有向图/无向图**：边是否有方向
- **加权图**：边带有权重
- **度（Degree）**：与顶点相连的边数
- **入度/出度**：有向图中指向/离开顶点的边数
- **路径**：顶点序列，相邻顶点间有边
- **环**：起点和终点相同的路径
- **连通图**：任意两点间都有路径

---

## 二、图的表示

### 1. 邻接矩阵

```python
class GraphMatrix:
    def __init__(self, num_vertices):
        self.V = num_vertices
        self.adj = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v, weight=1):
        self.adj[u][v] = weight
        self.adj[v][u] = weight  # 无向图
    
    def has_edge(self, u, v):
        return self.adj[u][v] != 0

# 适用场景：稠密图，需要快速判断两点是否相连
# 空间复杂度：O(V²)
```

### 2. 邻接表

```python
from collections import defaultdict

class GraphList:
    def __init__(self):
        self.adj = defaultdict(list)
    
    def add_edge(self, u, v, weight=1):
        self.adj[u].append((v, weight))
        self.adj[v].append((u, weight))  # 无向图
    
    def get_neighbors(self, u):
        return self.adj[u]

# 适用场景：稀疏图
# 空间复杂度：O(V + E)
```

### 3. 边列表

```python
class GraphEdges:
    def __init__(self, num_vertices):
        self.V = num_vertices
        self.edges = []  # [(u, v, weight), ...]
    
    def add_edge(self, u, v, weight=1):
        self.edges.append((u, v, weight))

# 适用场景：边操作为主的算法（如 Kruskal）
```

---

## 三、图的遍历

### 1. 深度优先搜索（DFS）

```python
def dfs_recursive(graph, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor, _ in graph.get_neighbors(start):
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)
    
    return visited

def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=' ')
            for neighbor, _ in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return visited
```

### 2. 广度优先搜索（BFS）

```python
from collections import deque

def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor, _ in graph.get_neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return visited

# BFS 可用于求无权图最短路径
def shortest_path_bfs(graph, start, end):
    if start == end:
        return [start]
    
    visited = set([start])
    queue = deque([(start, [start])])
    
    while queue:
        vertex, path = queue.popleft()
        
        for neighbor, _ in graph.get_neighbors(vertex):
            if neighbor == end:
                return path + [neighbor]
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None
```

---

## 四、最短路径算法

### 1. Dijkstra 算法（单源最短路径，非负权）

```python
import heapq

def dijkstra(graph, start):
    distances = {v: float('inf') for v in graph.adj}
    distances[start] = 0
    pq = [(0, start)]  # (距离, 顶点)
    
    while pq:
        current_dist, u = heapq.heappop(pq)
        
        if current_dist > distances[u]:
            continue
        
        for v, weight in graph.get_neighbors(u):
            distance = current_dist + weight
            if distance < distances[v]:
                distances[v] = distance
                heapq.heappush(pq, (distance, v))
    
    return distances

# 时间复杂度：O((V + E) log V)
```

### 2. Bellman-Ford 算法（可处理负权边）

```python
def bellman_ford(graph, start):
    distances = {v: float('inf') for v in graph.adj}
    distances[start] = 0
    
    # 松弛 V-1 次
    for _ in range(len(graph.adj) - 1):
        for u in graph.adj:
            for v, weight in graph.get_neighbors(u):
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
    
    # 检测负权环
    for u in graph.adj:
        for v, weight in graph.get_neighbors(u):
            if distances[u] + weight < distances[v]:
                raise ValueError("图中存在负权环")
    
    return distances

# 时间复杂度：O(VE)
```

### 3. Floyd-Warshall 算法（全源最短路径）

```python
def floyd_warshall(graph):
    V = len(graph.adj)
    vertices = list(graph.adj.keys())
    
    # 初始化距离矩阵
    dist = {u: {v: float('inf') for v in vertices} for u in vertices}
    for u in vertices:
        dist[u][u] = 0
        for v, weight in graph.get_neighbors(u):
            dist[u][v] = weight
    
    # 动态规划
    for k in vertices:
        for i in vertices:
            for j in vertices:
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# 时间复杂度：O(V³)
```

---

## 五、最小生成树

### 1. Prim 算法

```python
import heapq

def prim(graph, start):
    mst = []
    visited = set([start])
    edges = [(weight, start, v) for v, weight in graph.get_neighbors(start)]
    heapq.heapify(edges)
    
    while edges and len(mst) < len(graph.adj) - 1:
        weight, u, v = heapq.heappop(edges)
        if v in visited:
            continue
        
        visited.add(v)
        mst.append((u, v, weight))
        
        for next_v, next_weight in graph.get_neighbors(v):
            if next_v not in visited:
                heapq.heappush(edges, (next_weight, v, next_v))
    
    return mst

# 时间复杂度：O(E log V)
```

### 2. Kruskal 算法

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(graph):
    edges = sorted(graph.edges, key=lambda x: x[2])
    uf = UnionFind(graph.V)
    mst = []
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            if len(mst) == graph.V - 1:
                break
    
    return mst

# 时间复杂度：O(E log E)
```

---

## 六、拓扑排序

用于有向无环图（DAG），确定任务执行顺序。

```python
from collections import deque

def topological_sort(graph):
    # 计算入度
    in_degree = {v: 0 for v in graph.adj}
    for u in graph.adj:
        for v, _ in graph.get_neighbors(u):
            in_degree[v] += 1
    
    # 入度为 0 的顶点入队
    queue = deque([v for v in in_degree if in_degree[v] == 0])
    result = []
    
    while queue:
        u = queue.popleft()
        result.append(u)
        
        for v, _ in graph.get_neighbors(u):
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    if len(result) != len(graph.adj):
        raise ValueError("图中存在环")
    
    return result

# 时间复杂度：O(V + E)
```

---

## 七、环检测

### 有向图环检测（DFS）

```python
def has_cycle_directed(graph):
    WHITE, GRAY, BLACK = 0, 1, 2
    color = {v: WHITE for v in graph.adj}
    
    def dfs(u):
        color[u] = GRAY
        for v, _ in graph.get_neighbors(u):
            if color[v] == GRAY:
                return True
            if color[v] == WHITE and dfs(v):
                return True
        color[u] = BLACK
        return False
    
    for v in graph.adj:
        if color[v] == WHITE:
            if dfs(v):
                return True
    return False
```

---

## 八、算法复杂度总结

| 算法 | 时间复杂度 | 适用场景 |
|------|-----------|----------|
| BFS/DFS | O(V + E) | 遍历、连通性 |
| Dijkstra | O((V+E) log V) | 单源最短路径（非负权）|
| Bellman-Ford | O(VE) | 单源最短路径（可负权）|
| Floyd-Warshall | O(V³) | 全源最短路径 |
| Prim | O(E log V) | 最小生成树（稠密图）|
| Kruskal | O(E log E) | 最小生成树（稀疏图）|
| 拓扑排序 | O(V + E) | DAG 任务调度 |
