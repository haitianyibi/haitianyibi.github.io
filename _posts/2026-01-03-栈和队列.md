---
layout: post
title: "栈与队列详解"
date: 2026-01-03 10:00:00
tags: [数据结构, 栈, 队列]
---

# 栈与队列详解

## 一、栈（Stack）

栈是一种后进先出（LIFO - Last In First Out）的线性数据结构。

<!--more-->

### 核心操作

- **push(x)**：将元素压入栈顶 O(1)
- **pop()**：弹出栈顶元素 O(1)
- **peek/top()**：查看栈顶元素 O(1)
- **isEmpty()**：判断栈是否为空 O(1)

### 代码实现

```python
# Python 使用列表实现栈
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("Stack is empty")
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        raise IndexError("Stack is empty")
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# 使用示例
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())   # 输出: 3
print(stack.peek())  # 输出: 2
```

```java
// Java 使用 Deque 实现栈
import java.util.ArrayDeque;
import java.util.Deque;

Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.push(2);
stack.push(3);
System.out.println(stack.pop());   // 3
System.out.println(stack.peek());  // 2
```

### 经典应用

#### 1. 括号匹配

```python
def is_valid_parentheses(s: str) -> bool:
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            stack.append(char)
    
    return len(stack) == 0

# 测试
print(is_valid_parentheses("()[]{}"))  # True
print(is_valid_parentheses("([)]"))    # False
```

#### 2. 单调栈（下一个更大元素）

```python
def next_greater_element(nums):
    n = len(nums)
    result = [-1] * n
    stack = []  # 存储索引
    
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

# 示例: [1, 3, 2, 4] -> [3, 4, 4, -1]
```

---

## 二、队列（Queue）

队列是一种先进先出（FIFO - First In First Out）的线性数据结构。

### 核心操作

- **enqueue(x)**：入队，将元素加入队尾 O(1)
- **dequeue()**：出队，移除队首元素 O(1)
- **front/peek()**：查看队首元素 O(1)
- **isEmpty()**：判断队列是否为空 O(1)

### 代码实现

```python
from collections import deque

# Python 使用 deque 实现队列
class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        raise IndexError("Queue is empty")
    
    def front(self):
        if not self.is_empty():
            return self.items[0]
        raise IndexError("Queue is empty")
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# 使用示例
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue.dequeue())  # 输出: 1
print(queue.front())    # 输出: 2
```

```java
// Java 使用 LinkedList 实现队列
import java.util.LinkedList;
import java.util.Queue;

Queue<Integer> queue = new LinkedList<>();
queue.offer(1);  // 入队
queue.offer(2);
queue.offer(3);
System.out.println(queue.poll());  // 1 出队
System.out.println(queue.peek());  // 2 查看队首
```

---

## 三、双端队列（Deque）

双端队列支持在两端进行插入和删除操作。

```python
from collections import deque

dq = deque()

# 两端操作
dq.append(1)      # 右端添加
dq.appendleft(0)  # 左端添加
dq.pop()          # 右端删除
dq.popleft()      # 左端删除
```

### 滑动窗口最大值（单调队列）

```python
from collections import deque

def max_sliding_window(nums, k):
    result = []
    dq = deque()  # 存储索引，维护单调递减
    
    for i, num in enumerate(nums):
        # 移除超出窗口的元素
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护单调递减
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        dq.append(i)
        
        # 窗口形成后记录最大值
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# 示例: nums = [1,3,-1,-3,5,3,6,7], k = 3
# 输出: [3,3,5,5,6,7]
```

---

## 四、优先队列（Priority Queue）

优先队列是一种特殊的队列，出队顺序按照优先级而非入队顺序。通常使用堆实现。

```python
import heapq

# Python 使用 heapq（最小堆）
pq = []
heapq.heappush(pq, 3)
heapq.heappush(pq, 1)
heapq.heappush(pq, 2)

print(heapq.heappop(pq))  # 1 最小元素
print(heapq.heappop(pq))  # 2

# 最大堆（取负值）
max_pq = []
heapq.heappush(max_pq, -3)
heapq.heappush(max_pq, -1)
print(-heapq.heappop(max_pq))  # 3 最大元素
```

```java
// Java PriorityQueue
import java.util.PriorityQueue;

// 最小堆（默认）
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
minHeap.offer(3);
minHeap.offer(1);
minHeap.offer(2);
System.out.println(minHeap.poll());  // 1

// 最大堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
maxHeap.offer(3);
maxHeap.offer(1);
System.out.println(maxHeap.poll());  // 3
```

---

## 五、用栈实现队列

```python
class MyQueue:
    def __init__(self):
        self.stack_in = []
        self.stack_out = []
    
    def push(self, x: int) -> None:
        self.stack_in.append(x)
    
    def pop(self) -> int:
        self._transfer()
        return self.stack_out.pop()
    
    def peek(self) -> int:
        self._transfer()
        return self.stack_out[-1]
    
    def empty(self) -> bool:
        return not self.stack_in and not self.stack_out
    
    def _transfer(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
```
