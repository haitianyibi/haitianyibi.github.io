---
layout: post
title: "堆数据结构详解"
date: 2026-01-06 10:00:00
tags: [数据结构, 堆, 优先队列]
---

# 堆数据结构详解

## 一、堆的概念

堆（Heap）是一种特殊的完全二叉树，满足堆性质：

<!--more-->

- **最大堆**：父节点值 >= 子节点值
- **最小堆**：父节点值 <= 子节点值

### 数组表示

堆通常用数组存储，索引关系：

- 父节点：`(i - 1) // 2`
- 左子节点：`2 * i + 1`
- 右子节点：`2 * i + 2`

```
       10              索引: [10, 8, 9, 4, 5, 6, 7]
      /  \
     8    9            父(1) = 8
    / \  / \           左子(1) = 4, 右子(1) = 5
   4  5 6   7
```

---

## 二、堆的实现

### 最小堆实现

```python
class MinHeap:
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    # 上浮：新元素插入后向上调整
    def heapify_up(self, i):
        while i > 0 and self.heap[i] < self.heap[self.parent(i)]:
            self.swap(i, self.parent(i))
            i = self.parent(i)
    
    # 下沉：删除根后向下调整
    def heapify_down(self, i):
        smallest = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        
        if smallest != i:
            self.swap(i, smallest)
            self.heapify_down(smallest)
    
    # 插入元素 O(log n)
    def push(self, val):
        self.heap.append(val)
        self.heapify_up(len(self.heap) - 1)
    
    # 弹出最小元素 O(log n)
    def pop(self):
        if not self.heap:
            raise IndexError("Heap is empty")
        
        min_val = self.heap[0]
        last_val = self.heap.pop()
        
        if self.heap:
            self.heap[0] = last_val
            self.heapify_down(0)
        
        return min_val
    
    # 查看最小元素 O(1)
    def peek(self):
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def size(self):
        return len(self.heap)
    
    def is_empty(self):
        return len(self.heap) == 0
```

### 使用 Python heapq

```python
import heapq

# 最小堆
min_heap = []
heapq.heappush(min_heap, 5)
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 8)
heapq.heappush(min_heap, 1)

print(heapq.heappop(min_heap))  # 1
print(heapq.heappop(min_heap))  # 3

# 最大堆（取负值）
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -3)
print(-heapq.heappop(max_heap))  # 5

# 从列表建堆 O(n)
arr = [5, 3, 8, 1, 2]
heapq.heapify(arr)
print(arr)  # [1, 2, 8, 5, 3]

# 获取最小/最大的 k 个元素
nums = [5, 3, 8, 1, 2, 9, 4]
print(heapq.nsmallest(3, nums))  # [1, 2, 3]
print(heapq.nlargest(3, nums))   # [9, 8, 5]
```

### Java 优先队列

```java
import java.util.PriorityQueue;

// 最小堆（默认）
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
minHeap.offer(5);
minHeap.offer(3);
minHeap.offer(8);
System.out.println(minHeap.poll());  // 3

// 最大堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
maxHeap.offer(5);
maxHeap.offer(3);
maxHeap.offer(8);
System.out.println(maxHeap.poll());  // 8

// 自定义比较器
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
```

---

## 三、堆排序

```python
def heap_sort(arr):
    n = len(arr)
    
    # 建堆（从最后一个非叶节点开始）
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
print(heap_sort(arr))  # [11, 12, 22, 25, 34, 64, 90]
```

---

## 四、经典应用

### 1. Top K 问题

```python
import heapq

def top_k_frequent(nums, k):
    """找出出现频率最高的 k 个元素"""
    from collections import Counter
    count = Counter(nums)
    
    # 使用最小堆保持 k 个最大元素
    return heapq.nlargest(k, count.keys(), key=count.get)

# 示例
nums = [1, 1, 1, 2, 2, 3]
print(top_k_frequent(nums, 2))  # [1, 2]
```

### 2. 数据流中位数

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []  # 最大堆（存较小的一半，取负值）
        self.large = []  # 最小堆（存较大的一半）
    
    def addNum(self, num: int) -> None:
        # 先加入最大堆
        heapq.heappush(self.small, -num)
        
        # 确保 small 的最大值 <= large 的最小值
        if self.small and self.large and -self.small[0] > self.large[0]:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        
        # 平衡两个堆的大小
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```

### 3. 合并 K 个有序链表

```python
import heapq

def merge_k_lists(lists):
    heap = []
    
    # 初始化：将每个链表的头节点加入堆
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(heap, (head.val, i, head))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next
```

### 4. 任务调度器

```python
import heapq
from collections import Counter

def least_interval(tasks, n):
    """计算完成所有任务的最少时间"""
    count = Counter(tasks)
    max_heap = [-c for c in count.values()]
    heapq.heapify(max_heap)
    
    time = 0
    queue = []  # (可用时间, 剩余次数)
    
    while max_heap or queue:
        time += 1
        
        if max_heap:
            cnt = heapq.heappop(max_heap) + 1
            if cnt != 0:
                queue.append((time + n, cnt))
        
        if queue and queue[0][0] == time:
            heapq.heappush(max_heap, queue.pop(0)[1])
    
    return time
```

---

## 五、时间复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 插入 | O(log n) |
| 删除最值 | O(log n) |
| 查看最值 | O(1) |
| 建堆 | O(n) |
| 堆排序 | O(n log n) |

### 堆 vs 排序数组 vs BST

| 操作 | 堆 | 排序数组 | 平衡 BST |
|------|-----|---------|----------|
| 插入 | O(log n) | O(n) | O(log n) |
| 删除最值 | O(log n) | O(1) | O(log n) |
| 查找任意值 | O(n) | O(log n) | O(log n) |
| 建立 | O(n) | O(n log n) | O(n log n) |
